//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.13.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace ReSharperPlugin.AtomicPlugin.Model
{
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:10</p>
  /// </summary>
  public class AtomicGenerationModel : RdExtBase
  {
    //fields
    //public fields
    [NotNull] public IRdEndpoint<AtomicFileData, string> GenerateApi => _GenerateApi;
    [NotNull] public IRdEndpoint<TypeCompletionRequest, TypeCompletionResponse> GetTypeCompletions => _GetTypeCompletions;
    [NotNull] public IRdEndpoint<TypeValidationRequest, TypeValidationResponse> ValidateType => _ValidateType;
    [NotNull] public IRdEndpoint<Unit, string[]> GetAvailableProjects => _GetAvailableProjects;
    [NotNull] public IRdEndpoint<NamespaceCompletionRequest, NamespaceCompletionResponse> GetNamespaceCompletions => _GetNamespaceCompletions;
    [NotNull] public IRdEndpoint<NamespaceValidationRequest, NamespaceValidationResponse> ValidateNamespace => _ValidateNamespace;
    [NotNull] public IRdEndpoint<FindMethodUsagesRequest, FindMethodUsagesResponse> FindMethodUsages => _FindMethodUsages;
    [NotNull] public IRdEndpoint<FindTagUsagesRequest, FindTagUsagesResponse> FindTagUsages => _FindTagUsages;
    [NotNull] public IRdEndpoint<RenameValueRequest, RenameResponse> RenameValue => _RenameValue;
    [NotNull] public IRdEndpoint<RenameTagRequest, RenameResponse> RenameTag => _RenameTag;
    [NotNull] public IRdEndpoint<string, bool> AddAtomicFileToProject => _AddAtomicFileToProject;
    [NotNull] public void GenerationStatus(string value) => _GenerationStatus.Fire(value);
    
    //private fields
    [NotNull] private readonly RdCall<AtomicFileData, string> _GenerateApi;
    [NotNull] private readonly RdCall<TypeCompletionRequest, TypeCompletionResponse> _GetTypeCompletions;
    [NotNull] private readonly RdCall<TypeValidationRequest, TypeValidationResponse> _ValidateType;
    [NotNull] private readonly RdCall<Unit, string[]> _GetAvailableProjects;
    [NotNull] private readonly RdCall<NamespaceCompletionRequest, NamespaceCompletionResponse> _GetNamespaceCompletions;
    [NotNull] private readonly RdCall<NamespaceValidationRequest, NamespaceValidationResponse> _ValidateNamespace;
    [NotNull] private readonly RdCall<FindMethodUsagesRequest, FindMethodUsagesResponse> _FindMethodUsages;
    [NotNull] private readonly RdCall<FindTagUsagesRequest, FindTagUsagesResponse> _FindTagUsages;
    [NotNull] private readonly RdCall<RenameValueRequest, RenameResponse> _RenameValue;
    [NotNull] private readonly RdCall<RenameTagRequest, RenameResponse> _RenameTag;
    [NotNull] private readonly RdCall<string, bool> _AddAtomicFileToProject;
    [NotNull] private readonly RdSignal<string> _GenerationStatus;
    
    //primary constructor
    private AtomicGenerationModel(
      [NotNull] RdCall<AtomicFileData, string> generateApi,
      [NotNull] RdCall<TypeCompletionRequest, TypeCompletionResponse> getTypeCompletions,
      [NotNull] RdCall<TypeValidationRequest, TypeValidationResponse> validateType,
      [NotNull] RdCall<Unit, string[]> getAvailableProjects,
      [NotNull] RdCall<NamespaceCompletionRequest, NamespaceCompletionResponse> getNamespaceCompletions,
      [NotNull] RdCall<NamespaceValidationRequest, NamespaceValidationResponse> validateNamespace,
      [NotNull] RdCall<FindMethodUsagesRequest, FindMethodUsagesResponse> findMethodUsages,
      [NotNull] RdCall<FindTagUsagesRequest, FindTagUsagesResponse> findTagUsages,
      [NotNull] RdCall<RenameValueRequest, RenameResponse> renameValue,
      [NotNull] RdCall<RenameTagRequest, RenameResponse> renameTag,
      [NotNull] RdCall<string, bool> addAtomicFileToProject,
      [NotNull] RdSignal<string> generationStatus
    )
    {
      if (generateApi == null) throw new ArgumentNullException("generateApi");
      if (getTypeCompletions == null) throw new ArgumentNullException("getTypeCompletions");
      if (validateType == null) throw new ArgumentNullException("validateType");
      if (getAvailableProjects == null) throw new ArgumentNullException("getAvailableProjects");
      if (getNamespaceCompletions == null) throw new ArgumentNullException("getNamespaceCompletions");
      if (validateNamespace == null) throw new ArgumentNullException("validateNamespace");
      if (findMethodUsages == null) throw new ArgumentNullException("findMethodUsages");
      if (findTagUsages == null) throw new ArgumentNullException("findTagUsages");
      if (renameValue == null) throw new ArgumentNullException("renameValue");
      if (renameTag == null) throw new ArgumentNullException("renameTag");
      if (addAtomicFileToProject == null) throw new ArgumentNullException("addAtomicFileToProject");
      if (generationStatus == null) throw new ArgumentNullException("generationStatus");
      
      _GenerateApi = generateApi;
      _GetTypeCompletions = getTypeCompletions;
      _ValidateType = validateType;
      _GetAvailableProjects = getAvailableProjects;
      _GetNamespaceCompletions = getNamespaceCompletions;
      _ValidateNamespace = validateNamespace;
      _FindMethodUsages = findMethodUsages;
      _FindTagUsages = findTagUsages;
      _RenameValue = renameValue;
      _RenameTag = renameTag;
      _AddAtomicFileToProject = addAtomicFileToProject;
      _GenerationStatus = generationStatus;
      _GenerateApi.Async = true;
      _GetTypeCompletions.Async = true;
      _ValidateType.Async = true;
      _GetAvailableProjects.Async = true;
      _GetNamespaceCompletions.Async = true;
      _ValidateNamespace.Async = true;
      _FindMethodUsages.Async = true;
      _FindTagUsages.Async = true;
      _RenameValue.Async = true;
      _RenameTag.Async = true;
      _AddAtomicFileToProject.Async = true;
      _GenerationStatus.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("generateApi", _GenerateApi));
      BindableChildren.Add(new KeyValuePair<string, object>("getTypeCompletions", _GetTypeCompletions));
      BindableChildren.Add(new KeyValuePair<string, object>("validateType", _ValidateType));
      BindableChildren.Add(new KeyValuePair<string, object>("getAvailableProjects", _GetAvailableProjects));
      BindableChildren.Add(new KeyValuePair<string, object>("getNamespaceCompletions", _GetNamespaceCompletions));
      BindableChildren.Add(new KeyValuePair<string, object>("validateNamespace", _ValidateNamespace));
      BindableChildren.Add(new KeyValuePair<string, object>("findMethodUsages", _FindMethodUsages));
      BindableChildren.Add(new KeyValuePair<string, object>("findTagUsages", _FindTagUsages));
      BindableChildren.Add(new KeyValuePair<string, object>("renameValue", _RenameValue));
      BindableChildren.Add(new KeyValuePair<string, object>("renameTag", _RenameTag));
      BindableChildren.Add(new KeyValuePair<string, object>("addAtomicFileToProject", _AddAtomicFileToProject));
      BindableChildren.Add(new KeyValuePair<string, object>("generationStatus", _GenerationStatus));
    }
    //secondary constructor
    internal AtomicGenerationModel (
    ) : this (
      new RdCall<AtomicFileData, string>(AtomicFileData.Read, AtomicFileData.Write, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString),
      new RdCall<TypeCompletionRequest, TypeCompletionResponse>(TypeCompletionRequest.Read, TypeCompletionRequest.Write, TypeCompletionResponse.Read, TypeCompletionResponse.Write),
      new RdCall<TypeValidationRequest, TypeValidationResponse>(TypeValidationRequest.Read, TypeValidationRequest.Write, TypeValidationResponse.Read, TypeValidationResponse.Write),
      new RdCall<Unit, string[]>(JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid, ReadStringArray, WriteStringArray),
      new RdCall<NamespaceCompletionRequest, NamespaceCompletionResponse>(NamespaceCompletionRequest.Read, NamespaceCompletionRequest.Write, NamespaceCompletionResponse.Read, NamespaceCompletionResponse.Write),
      new RdCall<NamespaceValidationRequest, NamespaceValidationResponse>(NamespaceValidationRequest.Read, NamespaceValidationRequest.Write, NamespaceValidationResponse.Read, NamespaceValidationResponse.Write),
      new RdCall<FindMethodUsagesRequest, FindMethodUsagesResponse>(FindMethodUsagesRequest.Read, FindMethodUsagesRequest.Write, FindMethodUsagesResponse.Read, FindMethodUsagesResponse.Write),
      new RdCall<FindTagUsagesRequest, FindTagUsagesResponse>(FindTagUsagesRequest.Read, FindTagUsagesRequest.Write, FindTagUsagesResponse.Read, FindTagUsagesResponse.Write),
      new RdCall<RenameValueRequest, RenameResponse>(RenameValueRequest.Read, RenameValueRequest.Write, RenameResponse.Read, RenameResponse.Write),
      new RdCall<RenameTagRequest, RenameResponse>(RenameTagRequest.Read, RenameTagRequest.Write, RenameResponse.Read, RenameResponse.Write),
      new RdCall<string, bool>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdSignal<string>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString)
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    
    protected override long SerializationHash => 8091421013007210735L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      
      serializers.RegisterToplevelOnce(typeof(JetBrains.Rider.Model.IdeRoot), JetBrains.Rider.Model.IdeRoot.RegisterDeclaredTypesSerializers);
    }
    
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("AtomicGenerationModel (");
      using (printer.IndentCookie()) {
        printer.Print("generateApi = "); _GenerateApi.PrintEx(printer); printer.Println();
        printer.Print("getTypeCompletions = "); _GetTypeCompletions.PrintEx(printer); printer.Println();
        printer.Print("validateType = "); _ValidateType.PrintEx(printer); printer.Println();
        printer.Print("getAvailableProjects = "); _GetAvailableProjects.PrintEx(printer); printer.Println();
        printer.Print("getNamespaceCompletions = "); _GetNamespaceCompletions.PrintEx(printer); printer.Println();
        printer.Print("validateNamespace = "); _ValidateNamespace.PrintEx(printer); printer.Println();
        printer.Print("findMethodUsages = "); _FindMethodUsages.PrintEx(printer); printer.Println();
        printer.Print("findTagUsages = "); _FindTagUsages.PrintEx(printer); printer.Println();
        printer.Print("renameValue = "); _RenameValue.PrintEx(printer); printer.Println();
        printer.Print("renameTag = "); _RenameTag.PrintEx(printer); printer.Println();
        printer.Print("addAtomicFileToProject = "); _AddAtomicFileToProject.PrintEx(printer); printer.Println();
        printer.Print("generationStatus = "); _GenerationStatus.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  public static class SolutionAtomicGenerationModelEx
   {
    public static AtomicGenerationModel GetAtomicGenerationModel(this JetBrains.Rider.Model.Solution solution)
    {
      return solution.GetOrCreateExtension("atomicGenerationModel", () => new AtomicGenerationModel());
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:31</p>
  /// </summary>
  public sealed class AtomicFileData : IPrintable, IEquatable<AtomicFileData>
  {
    //fields
    //public fields
    [NotNull] public HeaderProperty[] HeaderProperties {get; private set;}
    [NotNull] public string[] Imports {get; private set;}
    [NotNull] public string[] Tags {get; private set;}
    [NotNull] public AtomicValueData[] Values {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public AtomicFileData(
      [NotNull] HeaderProperty[] headerProperties,
      [NotNull] string[] imports,
      [NotNull] string[] tags,
      [NotNull] AtomicValueData[] values,
      [NotNull] string filePath
    )
    {
      if (headerProperties == null) throw new ArgumentNullException("headerProperties");
      if (imports == null) throw new ArgumentNullException("imports");
      if (tags == null) throw new ArgumentNullException("tags");
      if (values == null) throw new ArgumentNullException("values");
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      HeaderProperties = headerProperties;
      Imports = imports;
      Tags = tags;
      Values = values;
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out HeaderProperty[] headerProperties, [NotNull] out string[] imports, [NotNull] out string[] tags, [NotNull] out AtomicValueData[] values, [NotNull] out string filePath)
    {
      headerProperties = HeaderProperties;
      imports = Imports;
      tags = Tags;
      values = Values;
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<AtomicFileData> Read = (ctx, reader) => 
    {
      var headerProperties = ReadHeaderPropertyArray(ctx, reader);
      var imports = ReadStringArray(ctx, reader);
      var tags = ReadStringArray(ctx, reader);
      var values = ReadAtomicValueDataArray(ctx, reader);
      var filePath = reader.ReadString();
      var _result = new AtomicFileData(headerProperties, imports, tags, values, filePath);
      return _result;
    };
    public static CtxReadDelegate<HeaderProperty[]> ReadHeaderPropertyArray = HeaderProperty.Read.Array();
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    public static CtxReadDelegate<AtomicValueData[]> ReadAtomicValueDataArray = AtomicValueData.Read.Array();
    
    public static CtxWriteDelegate<AtomicFileData> Write = (ctx, writer, value) => 
    {
      WriteHeaderPropertyArray(ctx, writer, value.HeaderProperties);
      WriteStringArray(ctx, writer, value.Imports);
      WriteStringArray(ctx, writer, value.Tags);
      WriteAtomicValueDataArray(ctx, writer, value.Values);
      writer.Write(value.FilePath);
    };
    public static  CtxWriteDelegate<HeaderProperty[]> WriteHeaderPropertyArray = HeaderProperty.Write.Array();
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    public static  CtxWriteDelegate<AtomicValueData[]> WriteAtomicValueDataArray = AtomicValueData.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((AtomicFileData) obj);
    }
    public bool Equals(AtomicFileData other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return HeaderProperties.SequenceEqual(other.HeaderProperties) && Imports.SequenceEqual(other.Imports) && Tags.SequenceEqual(other.Tags) && Values.SequenceEqual(other.Values) && FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + HeaderProperties.ContentHashCode();
        hash = hash * 31 + Imports.ContentHashCode();
        hash = hash * 31 + Tags.ContentHashCode();
        hash = hash * 31 + Values.ContentHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("AtomicFileData (");
      using (printer.IndentCookie()) {
        printer.Print("headerProperties = "); HeaderProperties.PrintEx(printer); printer.Println();
        printer.Print("imports = "); Imports.PrintEx(printer); printer.Println();
        printer.Print("tags = "); Tags.PrintEx(printer); printer.Println();
        printer.Print("values = "); Values.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:19</p>
  /// </summary>
  public sealed class AtomicValueData : IPrintable, IEquatable<AtomicValueData>
  {
    //fields
    //public fields
    [NotNull] public string Name {get; private set;}
    [NotNull] public string Type {get; private set;}
    
    //private fields
    //primary constructor
    public AtomicValueData(
      [NotNull] string name,
      [NotNull] string type
    )
    {
      if (name == null) throw new ArgumentNullException("name");
      if (type == null) throw new ArgumentNullException("type");
      
      Name = name;
      Type = type;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string name, [NotNull] out string type)
    {
      name = Name;
      type = Type;
    }
    //statics
    
    public static CtxReadDelegate<AtomicValueData> Read = (ctx, reader) => 
    {
      var name = reader.ReadString();
      var type = reader.ReadString();
      var _result = new AtomicValueData(name, type);
      return _result;
    };
    
    public static CtxWriteDelegate<AtomicValueData> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Name);
      writer.Write(value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((AtomicValueData) obj);
    }
    public bool Equals(AtomicValueData other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Name == other.Name && Type == other.Type;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("AtomicValueData (");
      using (printer.IndentCookie()) {
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:114</p>
  /// </summary>
  public sealed class FindMethodUsagesRequest : IPrintable, IEquatable<FindMethodUsagesRequest>
  {
    //fields
    //public fields
    [NotNull] public string ValueName {get; private set;}
    [NotNull] public string[] MethodNames {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    [NotNull] public string GeneratedFilePath {get; private set;}
    
    //private fields
    //primary constructor
    public FindMethodUsagesRequest(
      [NotNull] string valueName,
      [NotNull] string[] methodNames,
      [NotNull] string projectPath,
      [NotNull] string generatedFilePath
    )
    {
      if (valueName == null) throw new ArgumentNullException("valueName");
      if (methodNames == null) throw new ArgumentNullException("methodNames");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      if (generatedFilePath == null) throw new ArgumentNullException("generatedFilePath");
      
      ValueName = valueName;
      MethodNames = methodNames;
      ProjectPath = projectPath;
      GeneratedFilePath = generatedFilePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string valueName, [NotNull] out string[] methodNames, [NotNull] out string projectPath, [NotNull] out string generatedFilePath)
    {
      valueName = ValueName;
      methodNames = MethodNames;
      projectPath = ProjectPath;
      generatedFilePath = GeneratedFilePath;
    }
    //statics
    
    public static CtxReadDelegate<FindMethodUsagesRequest> Read = (ctx, reader) => 
    {
      var valueName = reader.ReadString();
      var methodNames = ReadStringArray(ctx, reader);
      var projectPath = reader.ReadString();
      var generatedFilePath = reader.ReadString();
      var _result = new FindMethodUsagesRequest(valueName, methodNames, projectPath, generatedFilePath);
      return _result;
    };
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    
    public static CtxWriteDelegate<FindMethodUsagesRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.ValueName);
      WriteStringArray(ctx, writer, value.MethodNames);
      writer.Write(value.ProjectPath);
      writer.Write(value.GeneratedFilePath);
    };
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((FindMethodUsagesRequest) obj);
    }
    public bool Equals(FindMethodUsagesRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return ValueName == other.ValueName && MethodNames.SequenceEqual(other.MethodNames) && ProjectPath == other.ProjectPath && GeneratedFilePath == other.GeneratedFilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ValueName.GetHashCode();
        hash = hash * 31 + MethodNames.ContentHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        hash = hash * 31 + GeneratedFilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("FindMethodUsagesRequest (");
      using (printer.IndentCookie()) {
        printer.Print("valueName = "); ValueName.PrintEx(printer); printer.Println();
        printer.Print("methodNames = "); MethodNames.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
        printer.Print("generatedFilePath = "); GeneratedFilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:121</p>
  /// </summary>
  public sealed class FindMethodUsagesResponse : IPrintable, IEquatable<FindMethodUsagesResponse>
  {
    //fields
    //public fields
    [NotNull] public MethodUsageLocation[] Usages {get; private set;}
    
    //private fields
    //primary constructor
    public FindMethodUsagesResponse(
      [NotNull] MethodUsageLocation[] usages
    )
    {
      if (usages == null) throw new ArgumentNullException("usages");
      
      Usages = usages;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out MethodUsageLocation[] usages)
    {
      usages = Usages;
    }
    //statics
    
    public static CtxReadDelegate<FindMethodUsagesResponse> Read = (ctx, reader) => 
    {
      var usages = ReadMethodUsageLocationArray(ctx, reader);
      var _result = new FindMethodUsagesResponse(usages);
      return _result;
    };
    public static CtxReadDelegate<MethodUsageLocation[]> ReadMethodUsageLocationArray = MethodUsageLocation.Read.Array();
    
    public static CtxWriteDelegate<FindMethodUsagesResponse> Write = (ctx, writer, value) => 
    {
      WriteMethodUsageLocationArray(ctx, writer, value.Usages);
    };
    public static  CtxWriteDelegate<MethodUsageLocation[]> WriteMethodUsageLocationArray = MethodUsageLocation.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((FindMethodUsagesResponse) obj);
    }
    public bool Equals(FindMethodUsagesResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Usages.SequenceEqual(other.Usages);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Usages.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("FindMethodUsagesResponse (");
      using (printer.IndentCookie()) {
        printer.Print("usages = "); Usages.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:125</p>
  /// </summary>
  public sealed class FindTagUsagesRequest : IPrintable, IEquatable<FindTagUsagesRequest>
  {
    //fields
    //public fields
    [NotNull] public string TagName {get; private set;}
    [NotNull] public string[] MethodNames {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    [NotNull] public string GeneratedFilePath {get; private set;}
    
    //private fields
    //primary constructor
    public FindTagUsagesRequest(
      [NotNull] string tagName,
      [NotNull] string[] methodNames,
      [NotNull] string projectPath,
      [NotNull] string generatedFilePath
    )
    {
      if (tagName == null) throw new ArgumentNullException("tagName");
      if (methodNames == null) throw new ArgumentNullException("methodNames");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      if (generatedFilePath == null) throw new ArgumentNullException("generatedFilePath");
      
      TagName = tagName;
      MethodNames = methodNames;
      ProjectPath = projectPath;
      GeneratedFilePath = generatedFilePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string tagName, [NotNull] out string[] methodNames, [NotNull] out string projectPath, [NotNull] out string generatedFilePath)
    {
      tagName = TagName;
      methodNames = MethodNames;
      projectPath = ProjectPath;
      generatedFilePath = GeneratedFilePath;
    }
    //statics
    
    public static CtxReadDelegate<FindTagUsagesRequest> Read = (ctx, reader) => 
    {
      var tagName = reader.ReadString();
      var methodNames = ReadStringArray(ctx, reader);
      var projectPath = reader.ReadString();
      var generatedFilePath = reader.ReadString();
      var _result = new FindTagUsagesRequest(tagName, methodNames, projectPath, generatedFilePath);
      return _result;
    };
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    
    public static CtxWriteDelegate<FindTagUsagesRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.TagName);
      WriteStringArray(ctx, writer, value.MethodNames);
      writer.Write(value.ProjectPath);
      writer.Write(value.GeneratedFilePath);
    };
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((FindTagUsagesRequest) obj);
    }
    public bool Equals(FindTagUsagesRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return TagName == other.TagName && MethodNames.SequenceEqual(other.MethodNames) && ProjectPath == other.ProjectPath && GeneratedFilePath == other.GeneratedFilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TagName.GetHashCode();
        hash = hash * 31 + MethodNames.ContentHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        hash = hash * 31 + GeneratedFilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("FindTagUsagesRequest (");
      using (printer.IndentCookie()) {
        printer.Print("tagName = "); TagName.PrintEx(printer); printer.Println();
        printer.Print("methodNames = "); MethodNames.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
        printer.Print("generatedFilePath = "); GeneratedFilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:132</p>
  /// </summary>
  public sealed class FindTagUsagesResponse : IPrintable, IEquatable<FindTagUsagesResponse>
  {
    //fields
    //public fields
    [NotNull] public MethodUsageLocation[] Usages {get; private set;}
    
    //private fields
    //primary constructor
    public FindTagUsagesResponse(
      [NotNull] MethodUsageLocation[] usages
    )
    {
      if (usages == null) throw new ArgumentNullException("usages");
      
      Usages = usages;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out MethodUsageLocation[] usages)
    {
      usages = Usages;
    }
    //statics
    
    public static CtxReadDelegate<FindTagUsagesResponse> Read = (ctx, reader) => 
    {
      var usages = ReadMethodUsageLocationArray(ctx, reader);
      var _result = new FindTagUsagesResponse(usages);
      return _result;
    };
    public static CtxReadDelegate<MethodUsageLocation[]> ReadMethodUsageLocationArray = MethodUsageLocation.Read.Array();
    
    public static CtxWriteDelegate<FindTagUsagesResponse> Write = (ctx, writer, value) => 
    {
      WriteMethodUsageLocationArray(ctx, writer, value.Usages);
    };
    public static  CtxWriteDelegate<MethodUsageLocation[]> WriteMethodUsageLocationArray = MethodUsageLocation.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((FindTagUsagesResponse) obj);
    }
    public bool Equals(FindTagUsagesResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Usages.SequenceEqual(other.Usages);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Usages.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("FindTagUsagesResponse (");
      using (printer.IndentCookie()) {
        printer.Print("usages = "); Usages.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:25</p>
  /// </summary>
  public sealed class HeaderProperty : IPrintable, IEquatable<HeaderProperty>
  {
    //fields
    //public fields
    [NotNull] public string Key {get; private set;}
    [NotNull] public string Value {get; private set;}
    
    //private fields
    //primary constructor
    public HeaderProperty(
      [NotNull] string key,
      [NotNull] string value
    )
    {
      if (key == null) throw new ArgumentNullException("key");
      if (value == null) throw new ArgumentNullException("value");
      
      Key = key;
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string key, [NotNull] out string value)
    {
      key = Key;
      value = Value;
    }
    //statics
    
    public static CtxReadDelegate<HeaderProperty> Read = (ctx, reader) => 
    {
      var key = reader.ReadString();
      var value = reader.ReadString();
      var _result = new HeaderProperty(key, value);
      return _result;
    };
    
    public static CtxWriteDelegate<HeaderProperty> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Key);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((HeaderProperty) obj);
    }
    public bool Equals(HeaderProperty other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Key == other.Key && Value == other.Value;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Key.GetHashCode();
        hash = hash * 31 + Value.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("HeaderProperty (");
      using (printer.IndentCookie()) {
        printer.Print("key = "); Key.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:106</p>
  /// </summary>
  public sealed class MethodUsageLocation : IPrintable, IEquatable<MethodUsageLocation>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    public int Line {get; private set;}
    public int Column {get; private set;}
    [NotNull] public string MethodName {get; private set;}
    [NotNull] public string UsageText {get; private set;}
    
    //private fields
    //primary constructor
    public MethodUsageLocation(
      [NotNull] string filePath,
      int line,
      int column,
      [NotNull] string methodName,
      [NotNull] string usageText
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      if (methodName == null) throw new ArgumentNullException("methodName");
      if (usageText == null) throw new ArgumentNullException("usageText");
      
      FilePath = filePath;
      Line = line;
      Column = column;
      MethodName = methodName;
      UsageText = usageText;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath, out int line, out int column, [NotNull] out string methodName, [NotNull] out string usageText)
    {
      filePath = FilePath;
      line = Line;
      column = Column;
      methodName = MethodName;
      usageText = UsageText;
    }
    //statics
    
    public static CtxReadDelegate<MethodUsageLocation> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var line = reader.ReadInt();
      var column = reader.ReadInt();
      var methodName = reader.ReadString();
      var usageText = reader.ReadString();
      var _result = new MethodUsageLocation(filePath, line, column, methodName, usageText);
      return _result;
    };
    
    public static CtxWriteDelegate<MethodUsageLocation> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
      writer.Write(value.Line);
      writer.Write(value.Column);
      writer.Write(value.MethodName);
      writer.Write(value.UsageText);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((MethodUsageLocation) obj);
    }
    public bool Equals(MethodUsageLocation other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath && Line == other.Line && Column == other.Column && MethodName == other.MethodName && UsageText == other.UsageText;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        hash = hash * 31 + Line.GetHashCode();
        hash = hash * 31 + Column.GetHashCode();
        hash = hash * 31 + MethodName.GetHashCode();
        hash = hash * 31 + UsageText.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("MethodUsageLocation (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
        printer.Print("line = "); Line.PrintEx(printer); printer.Println();
        printer.Print("column = "); Column.PrintEx(printer); printer.Println();
        printer.Print("methodName = "); MethodName.PrintEx(printer); printer.Println();
        printer.Print("usageText = "); UsageText.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:85</p>
  /// </summary>
  public sealed class NamespaceCompletionRequest : IPrintable, IEquatable<NamespaceCompletionRequest>
  {
    //fields
    //public fields
    [NotNull] public string Prefix {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    
    //private fields
    //primary constructor
    public NamespaceCompletionRequest(
      [NotNull] string prefix,
      [NotNull] string projectPath
    )
    {
      if (prefix == null) throw new ArgumentNullException("prefix");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      
      Prefix = prefix;
      ProjectPath = projectPath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string prefix, [NotNull] out string projectPath)
    {
      prefix = Prefix;
      projectPath = ProjectPath;
    }
    //statics
    
    public static CtxReadDelegate<NamespaceCompletionRequest> Read = (ctx, reader) => 
    {
      var prefix = reader.ReadString();
      var projectPath = reader.ReadString();
      var _result = new NamespaceCompletionRequest(prefix, projectPath);
      return _result;
    };
    
    public static CtxWriteDelegate<NamespaceCompletionRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Prefix);
      writer.Write(value.ProjectPath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((NamespaceCompletionRequest) obj);
    }
    public bool Equals(NamespaceCompletionRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Prefix == other.Prefix && ProjectPath == other.ProjectPath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Prefix.GetHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("NamespaceCompletionRequest (");
      using (printer.IndentCookie()) {
        printer.Print("prefix = "); Prefix.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:90</p>
  /// </summary>
  public sealed class NamespaceCompletionResponse : IPrintable, IEquatable<NamespaceCompletionResponse>
  {
    //fields
    //public fields
    [NotNull] public string[] Namespaces {get; private set;}
    
    //private fields
    //primary constructor
    public NamespaceCompletionResponse(
      [NotNull] string[] namespaces
    )
    {
      if (namespaces == null) throw new ArgumentNullException("namespaces");
      
      Namespaces = namespaces;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string[] namespaces)
    {
      namespaces = Namespaces;
    }
    //statics
    
    public static CtxReadDelegate<NamespaceCompletionResponse> Read = (ctx, reader) => 
    {
      var namespaces = ReadStringArray(ctx, reader);
      var _result = new NamespaceCompletionResponse(namespaces);
      return _result;
    };
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    
    public static CtxWriteDelegate<NamespaceCompletionResponse> Write = (ctx, writer, value) => 
    {
      WriteStringArray(ctx, writer, value.Namespaces);
    };
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((NamespaceCompletionResponse) obj);
    }
    public bool Equals(NamespaceCompletionResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Namespaces.SequenceEqual(other.Namespaces);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Namespaces.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("NamespaceCompletionResponse (");
      using (printer.IndentCookie()) {
        printer.Print("namespaces = "); Namespaces.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:95</p>
  /// </summary>
  public sealed class NamespaceValidationRequest : IPrintable, IEquatable<NamespaceValidationRequest>
  {
    //fields
    //public fields
    [NotNull] public string Namespace {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    
    //private fields
    //primary constructor
    public NamespaceValidationRequest(
      [NotNull] string @namespace,
      [NotNull] string projectPath
    )
    {
      if (@namespace == null) throw new ArgumentNullException("namespace");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      
      Namespace = @namespace;
      ProjectPath = projectPath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string @namespace, [NotNull] out string projectPath)
    {
      @namespace = Namespace;
      projectPath = ProjectPath;
    }
    //statics
    
    public static CtxReadDelegate<NamespaceValidationRequest> Read = (ctx, reader) => 
    {
      var @namespace = reader.ReadString();
      var projectPath = reader.ReadString();
      var _result = new NamespaceValidationRequest(@namespace, projectPath);
      return _result;
    };
    
    public static CtxWriteDelegate<NamespaceValidationRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Namespace);
      writer.Write(value.ProjectPath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((NamespaceValidationRequest) obj);
    }
    public bool Equals(NamespaceValidationRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Namespace == other.Namespace && ProjectPath == other.ProjectPath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Namespace.GetHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("NamespaceValidationRequest (");
      using (printer.IndentCookie()) {
        printer.Print("namespace = "); Namespace.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:100</p>
  /// </summary>
  public sealed class NamespaceValidationResponse : IPrintable, IEquatable<NamespaceValidationResponse>
  {
    //fields
    //public fields
    public bool IsValid {get; private set;}
    public bool HasTypes {get; private set;}
    
    //private fields
    //primary constructor
    public NamespaceValidationResponse(
      bool isValid,
      bool hasTypes
    )
    {
      IsValid = isValid;
      HasTypes = hasTypes;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool isValid, out bool hasTypes)
    {
      isValid = IsValid;
      hasTypes = HasTypes;
    }
    //statics
    
    public static CtxReadDelegate<NamespaceValidationResponse> Read = (ctx, reader) => 
    {
      var isValid = reader.ReadBool();
      var hasTypes = reader.ReadBool();
      var _result = new NamespaceValidationResponse(isValid, hasTypes);
      return _result;
    };
    
    public static CtxWriteDelegate<NamespaceValidationResponse> Write = (ctx, writer, value) => 
    {
      writer.Write(value.IsValid);
      writer.Write(value.HasTypes);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((NamespaceValidationResponse) obj);
    }
    public bool Equals(NamespaceValidationResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return IsValid == other.IsValid && HasTypes == other.HasTypes;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + IsValid.GetHashCode();
        hash = hash * 31 + HasTypes.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("NamespaceValidationResponse (");
      using (printer.IndentCookie()) {
        printer.Print("isValid = "); IsValid.PrintEx(printer); printer.Println();
        printer.Print("hasTypes = "); HasTypes.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:150</p>
  /// </summary>
  public sealed class RenameResponse : IPrintable, IEquatable<RenameResponse>
  {
    //fields
    //public fields
    public bool Success {get; private set;}
    [CanBeNull] public string RegeneratedFilePath {get; private set;}
    [NotNull] public MethodUsageLocation[] UpdatedUsages {get; private set;}
    [CanBeNull] public string ErrorMessage {get; private set;}
    
    //private fields
    //primary constructor
    public RenameResponse(
      bool success,
      [CanBeNull] string regeneratedFilePath,
      [NotNull] MethodUsageLocation[] updatedUsages,
      [CanBeNull] string errorMessage
    )
    {
      if (updatedUsages == null) throw new ArgumentNullException("updatedUsages");
      
      Success = success;
      RegeneratedFilePath = regeneratedFilePath;
      UpdatedUsages = updatedUsages;
      ErrorMessage = errorMessage;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool success, [CanBeNull] out string regeneratedFilePath, [NotNull] out MethodUsageLocation[] updatedUsages, [CanBeNull] out string errorMessage)
    {
      success = Success;
      regeneratedFilePath = RegeneratedFilePath;
      updatedUsages = UpdatedUsages;
      errorMessage = ErrorMessage;
    }
    //statics
    
    public static CtxReadDelegate<RenameResponse> Read = (ctx, reader) => 
    {
      var success = reader.ReadBool();
      var regeneratedFilePath = ReadStringNullable(ctx, reader);
      var updatedUsages = ReadMethodUsageLocationArray(ctx, reader);
      var errorMessage = ReadStringNullable(ctx, reader);
      var _result = new RenameResponse(success, regeneratedFilePath, updatedUsages, errorMessage);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    public static CtxReadDelegate<MethodUsageLocation[]> ReadMethodUsageLocationArray = MethodUsageLocation.Read.Array();
    
    public static CtxWriteDelegate<RenameResponse> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Success);
      WriteStringNullable(ctx, writer, value.RegeneratedFilePath);
      WriteMethodUsageLocationArray(ctx, writer, value.UpdatedUsages);
      WriteStringNullable(ctx, writer, value.ErrorMessage);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    public static  CtxWriteDelegate<MethodUsageLocation[]> WriteMethodUsageLocationArray = MethodUsageLocation.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((RenameResponse) obj);
    }
    public bool Equals(RenameResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Success == other.Success && Equals(RegeneratedFilePath, other.RegeneratedFilePath) && UpdatedUsages.SequenceEqual(other.UpdatedUsages) && Equals(ErrorMessage, other.ErrorMessage);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Success.GetHashCode();
        hash = hash * 31 + (RegeneratedFilePath != null ? RegeneratedFilePath.GetHashCode() : 0);
        hash = hash * 31 + UpdatedUsages.ContentHashCode();
        hash = hash * 31 + (ErrorMessage != null ? ErrorMessage.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("RenameResponse (");
      using (printer.IndentCookie()) {
        printer.Print("success = "); Success.PrintEx(printer); printer.Println();
        printer.Print("regeneratedFilePath = "); RegeneratedFilePath.PrintEx(printer); printer.Println();
        printer.Print("updatedUsages = "); UpdatedUsages.PrintEx(printer); printer.Println();
        printer.Print("errorMessage = "); ErrorMessage.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:143</p>
  /// </summary>
  public sealed class RenameTagRequest : IPrintable, IEquatable<RenameTagRequest>
  {
    //fields
    //public fields
    [NotNull] public string AtomicFilePath {get; private set;}
    [NotNull] public string OldName {get; private set;}
    [NotNull] public string NewName {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    
    //private fields
    //primary constructor
    public RenameTagRequest(
      [NotNull] string atomicFilePath,
      [NotNull] string oldName,
      [NotNull] string newName,
      [NotNull] string projectPath
    )
    {
      if (atomicFilePath == null) throw new ArgumentNullException("atomicFilePath");
      if (oldName == null) throw new ArgumentNullException("oldName");
      if (newName == null) throw new ArgumentNullException("newName");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      
      AtomicFilePath = atomicFilePath;
      OldName = oldName;
      NewName = newName;
      ProjectPath = projectPath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string atomicFilePath, [NotNull] out string oldName, [NotNull] out string newName, [NotNull] out string projectPath)
    {
      atomicFilePath = AtomicFilePath;
      oldName = OldName;
      newName = NewName;
      projectPath = ProjectPath;
    }
    //statics
    
    public static CtxReadDelegate<RenameTagRequest> Read = (ctx, reader) => 
    {
      var atomicFilePath = reader.ReadString();
      var oldName = reader.ReadString();
      var newName = reader.ReadString();
      var projectPath = reader.ReadString();
      var _result = new RenameTagRequest(atomicFilePath, oldName, newName, projectPath);
      return _result;
    };
    
    public static CtxWriteDelegate<RenameTagRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AtomicFilePath);
      writer.Write(value.OldName);
      writer.Write(value.NewName);
      writer.Write(value.ProjectPath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((RenameTagRequest) obj);
    }
    public bool Equals(RenameTagRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AtomicFilePath == other.AtomicFilePath && OldName == other.OldName && NewName == other.NewName && ProjectPath == other.ProjectPath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AtomicFilePath.GetHashCode();
        hash = hash * 31 + OldName.GetHashCode();
        hash = hash * 31 + NewName.GetHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("RenameTagRequest (");
      using (printer.IndentCookie()) {
        printer.Print("atomicFilePath = "); AtomicFilePath.PrintEx(printer); printer.Println();
        printer.Print("oldName = "); OldName.PrintEx(printer); printer.Println();
        printer.Print("newName = "); NewName.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:136</p>
  /// </summary>
  public sealed class RenameValueRequest : IPrintable, IEquatable<RenameValueRequest>
  {
    //fields
    //public fields
    [NotNull] public string AtomicFilePath {get; private set;}
    [NotNull] public string OldName {get; private set;}
    [NotNull] public string NewName {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    
    //private fields
    //primary constructor
    public RenameValueRequest(
      [NotNull] string atomicFilePath,
      [NotNull] string oldName,
      [NotNull] string newName,
      [NotNull] string projectPath
    )
    {
      if (atomicFilePath == null) throw new ArgumentNullException("atomicFilePath");
      if (oldName == null) throw new ArgumentNullException("oldName");
      if (newName == null) throw new ArgumentNullException("newName");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      
      AtomicFilePath = atomicFilePath;
      OldName = oldName;
      NewName = newName;
      ProjectPath = projectPath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string atomicFilePath, [NotNull] out string oldName, [NotNull] out string newName, [NotNull] out string projectPath)
    {
      atomicFilePath = AtomicFilePath;
      oldName = OldName;
      newName = NewName;
      projectPath = ProjectPath;
    }
    //statics
    
    public static CtxReadDelegate<RenameValueRequest> Read = (ctx, reader) => 
    {
      var atomicFilePath = reader.ReadString();
      var oldName = reader.ReadString();
      var newName = reader.ReadString();
      var projectPath = reader.ReadString();
      var _result = new RenameValueRequest(atomicFilePath, oldName, newName, projectPath);
      return _result;
    };
    
    public static CtxWriteDelegate<RenameValueRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AtomicFilePath);
      writer.Write(value.OldName);
      writer.Write(value.NewName);
      writer.Write(value.ProjectPath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((RenameValueRequest) obj);
    }
    public bool Equals(RenameValueRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AtomicFilePath == other.AtomicFilePath && OldName == other.OldName && NewName == other.NewName && ProjectPath == other.ProjectPath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AtomicFilePath.GetHashCode();
        hash = hash * 31 + OldName.GetHashCode();
        hash = hash * 31 + NewName.GetHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("RenameValueRequest (");
      using (printer.IndentCookie()) {
        printer.Print("atomicFilePath = "); AtomicFilePath.PrintEx(printer); printer.Println();
        printer.Print("oldName = "); OldName.PrintEx(printer); printer.Println();
        printer.Print("newName = "); NewName.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:48</p>
  /// </summary>
  public sealed class TypeCompletionItem : IPrintable, IEquatable<TypeCompletionItem>
  {
    //fields
    //public fields
    [NotNull] public string TypeName {get; private set;}
    [NotNull] public string FullTypeName {get; private set;}
    [NotNull] public string Namespace {get; private set;}
    [NotNull] public string AssemblyName {get; private set;}
    public bool IsGeneric {get; private set;}
    public ReSharperPlugin.AtomicPlugin.Model.TypeKind TypeKind {get; private set;}
    
    //private fields
    //primary constructor
    public TypeCompletionItem(
      [NotNull] string typeName,
      [NotNull] string fullTypeName,
      [NotNull] string @namespace,
      [NotNull] string assemblyName,
      bool isGeneric,
      ReSharperPlugin.AtomicPlugin.Model.TypeKind typeKind
    )
    {
      if (typeName == null) throw new ArgumentNullException("typeName");
      if (fullTypeName == null) throw new ArgumentNullException("fullTypeName");
      if (@namespace == null) throw new ArgumentNullException("namespace");
      if (assemblyName == null) throw new ArgumentNullException("assemblyName");
      
      TypeName = typeName;
      FullTypeName = fullTypeName;
      Namespace = @namespace;
      AssemblyName = assemblyName;
      IsGeneric = isGeneric;
      TypeKind = typeKind;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string typeName, [NotNull] out string fullTypeName, [NotNull] out string @namespace, [NotNull] out string assemblyName, out bool isGeneric, out ReSharperPlugin.AtomicPlugin.Model.TypeKind typeKind)
    {
      typeName = TypeName;
      fullTypeName = FullTypeName;
      @namespace = Namespace;
      assemblyName = AssemblyName;
      isGeneric = IsGeneric;
      typeKind = TypeKind;
    }
    //statics
    
    public static CtxReadDelegate<TypeCompletionItem> Read = (ctx, reader) => 
    {
      var typeName = reader.ReadString();
      var fullTypeName = reader.ReadString();
      var @namespace = reader.ReadString();
      var assemblyName = reader.ReadString();
      var isGeneric = reader.ReadBool();
      var typeKind = (ReSharperPlugin.AtomicPlugin.Model.TypeKind)reader.ReadInt();
      var _result = new TypeCompletionItem(typeName, fullTypeName, @namespace, assemblyName, isGeneric, typeKind);
      return _result;
    };
    
    public static CtxWriteDelegate<TypeCompletionItem> Write = (ctx, writer, value) => 
    {
      writer.Write(value.TypeName);
      writer.Write(value.FullTypeName);
      writer.Write(value.Namespace);
      writer.Write(value.AssemblyName);
      writer.Write(value.IsGeneric);
      writer.Write((int)value.TypeKind);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeCompletionItem) obj);
    }
    public bool Equals(TypeCompletionItem other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return TypeName == other.TypeName && FullTypeName == other.FullTypeName && Namespace == other.Namespace && AssemblyName == other.AssemblyName && IsGeneric == other.IsGeneric && TypeKind == other.TypeKind;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TypeName.GetHashCode();
        hash = hash * 31 + FullTypeName.GetHashCode();
        hash = hash * 31 + Namespace.GetHashCode();
        hash = hash * 31 + AssemblyName.GetHashCode();
        hash = hash * 31 + IsGeneric.GetHashCode();
        hash = hash * 31 + (int) TypeKind;
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeCompletionItem (");
      using (printer.IndentCookie()) {
        printer.Print("typeName = "); TypeName.PrintEx(printer); printer.Println();
        printer.Print("fullTypeName = "); FullTypeName.PrintEx(printer); printer.Println();
        printer.Print("namespace = "); Namespace.PrintEx(printer); printer.Println();
        printer.Print("assemblyName = "); AssemblyName.PrintEx(printer); printer.Println();
        printer.Print("isGeneric = "); IsGeneric.PrintEx(printer); printer.Println();
        printer.Print("typeKind = "); TypeKind.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:57</p>
  /// </summary>
  public sealed class TypeCompletionRequest : IPrintable, IEquatable<TypeCompletionRequest>
  {
    //fields
    //public fields
    [NotNull] public string Prefix {get; private set;}
    [NotNull] public string[] Imports {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    [CanBeNull] public string NamespaceFilter {get; private set;}
    
    //private fields
    //primary constructor
    public TypeCompletionRequest(
      [NotNull] string prefix,
      [NotNull] string[] imports,
      [NotNull] string projectPath,
      [CanBeNull] string namespaceFilter
    )
    {
      if (prefix == null) throw new ArgumentNullException("prefix");
      if (imports == null) throw new ArgumentNullException("imports");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      
      Prefix = prefix;
      Imports = imports;
      ProjectPath = projectPath;
      NamespaceFilter = namespaceFilter;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string prefix, [NotNull] out string[] imports, [NotNull] out string projectPath, [CanBeNull] out string namespaceFilter)
    {
      prefix = Prefix;
      imports = Imports;
      projectPath = ProjectPath;
      namespaceFilter = NamespaceFilter;
    }
    //statics
    
    public static CtxReadDelegate<TypeCompletionRequest> Read = (ctx, reader) => 
    {
      var prefix = reader.ReadString();
      var imports = ReadStringArray(ctx, reader);
      var projectPath = reader.ReadString();
      var namespaceFilter = ReadStringNullable(ctx, reader);
      var _result = new TypeCompletionRequest(prefix, imports, projectPath, namespaceFilter);
      return _result;
    };
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<TypeCompletionRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Prefix);
      WriteStringArray(ctx, writer, value.Imports);
      writer.Write(value.ProjectPath);
      WriteStringNullable(ctx, writer, value.NamespaceFilter);
    };
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeCompletionRequest) obj);
    }
    public bool Equals(TypeCompletionRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Prefix == other.Prefix && Imports.SequenceEqual(other.Imports) && ProjectPath == other.ProjectPath && Equals(NamespaceFilter, other.NamespaceFilter);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Prefix.GetHashCode();
        hash = hash * 31 + Imports.ContentHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        hash = hash * 31 + (NamespaceFilter != null ? NamespaceFilter.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeCompletionRequest (");
      using (printer.IndentCookie()) {
        printer.Print("prefix = "); Prefix.PrintEx(printer); printer.Println();
        printer.Print("imports = "); Imports.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
        printer.Print("namespaceFilter = "); NamespaceFilter.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:64</p>
  /// </summary>
  public sealed class TypeCompletionResponse : IPrintable, IEquatable<TypeCompletionResponse>
  {
    //fields
    //public fields
    [NotNull] public TypeCompletionItem[] Items {get; private set;}
    
    //private fields
    //primary constructor
    public TypeCompletionResponse(
      [NotNull] TypeCompletionItem[] items
    )
    {
      if (items == null) throw new ArgumentNullException("items");
      
      Items = items;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out TypeCompletionItem[] items)
    {
      items = Items;
    }
    //statics
    
    public static CtxReadDelegate<TypeCompletionResponse> Read = (ctx, reader) => 
    {
      var items = ReadTypeCompletionItemArray(ctx, reader);
      var _result = new TypeCompletionResponse(items);
      return _result;
    };
    public static CtxReadDelegate<TypeCompletionItem[]> ReadTypeCompletionItemArray = TypeCompletionItem.Read.Array();
    
    public static CtxWriteDelegate<TypeCompletionResponse> Write = (ctx, writer, value) => 
    {
      WriteTypeCompletionItemArray(ctx, writer, value.Items);
    };
    public static  CtxWriteDelegate<TypeCompletionItem[]> WriteTypeCompletionItemArray = TypeCompletionItem.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeCompletionResponse) obj);
    }
    public bool Equals(TypeCompletionResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Items.SequenceEqual(other.Items);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Items.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeCompletionResponse (");
      using (printer.IndentCookie()) {
        printer.Print("items = "); Items.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:40</p>
  /// </summary>
  public enum TypeKind {
    Class,
    Interface,
    Struct,
    Enum,
    Delegate
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:69</p>
  /// </summary>
  public sealed class TypeValidationRequest : IPrintable, IEquatable<TypeValidationRequest>
  {
    //fields
    //public fields
    [NotNull] public string TypeName {get; private set;}
    [NotNull] public string[] Imports {get; private set;}
    [NotNull] public string ProjectPath {get; private set;}
    
    //private fields
    //primary constructor
    public TypeValidationRequest(
      [NotNull] string typeName,
      [NotNull] string[] imports,
      [NotNull] string projectPath
    )
    {
      if (typeName == null) throw new ArgumentNullException("typeName");
      if (imports == null) throw new ArgumentNullException("imports");
      if (projectPath == null) throw new ArgumentNullException("projectPath");
      
      TypeName = typeName;
      Imports = imports;
      ProjectPath = projectPath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string typeName, [NotNull] out string[] imports, [NotNull] out string projectPath)
    {
      typeName = TypeName;
      imports = Imports;
      projectPath = ProjectPath;
    }
    //statics
    
    public static CtxReadDelegate<TypeValidationRequest> Read = (ctx, reader) => 
    {
      var typeName = reader.ReadString();
      var imports = ReadStringArray(ctx, reader);
      var projectPath = reader.ReadString();
      var _result = new TypeValidationRequest(typeName, imports, projectPath);
      return _result;
    };
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    
    public static CtxWriteDelegate<TypeValidationRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.TypeName);
      WriteStringArray(ctx, writer, value.Imports);
      writer.Write(value.ProjectPath);
    };
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeValidationRequest) obj);
    }
    public bool Equals(TypeValidationRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return TypeName == other.TypeName && Imports.SequenceEqual(other.Imports) && ProjectPath == other.ProjectPath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TypeName.GetHashCode();
        hash = hash * 31 + Imports.ContentHashCode();
        hash = hash * 31 + ProjectPath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeValidationRequest (");
      using (printer.IndentCookie()) {
        printer.Print("typeName = "); TypeName.PrintEx(printer); printer.Println();
        printer.Print("imports = "); Imports.PrintEx(printer); printer.Println();
        printer.Print("projectPath = "); ProjectPath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: AtomicGenerationModel.kt:75</p>
  /// </summary>
  public sealed class TypeValidationResponse : IPrintable, IEquatable<TypeValidationResponse>
  {
    //fields
    //public fields
    public bool IsValid {get; private set;}
    [CanBeNull] public string FullTypeName {get; private set;}
    [CanBeNull] public string SuggestedImport {get; private set;}
    [NotNull] public string[] SuggestedImports {get; private set;}
    public bool IsAmbiguous {get; private set;}
    [NotNull] public string[] AmbiguousNamespaces {get; private set;}
    
    //private fields
    //primary constructor
    public TypeValidationResponse(
      bool isValid,
      [CanBeNull] string fullTypeName,
      [CanBeNull] string suggestedImport,
      [NotNull] string[] suggestedImports,
      bool isAmbiguous,
      [NotNull] string[] ambiguousNamespaces
    )
    {
      if (suggestedImports == null) throw new ArgumentNullException("suggestedImports");
      if (ambiguousNamespaces == null) throw new ArgumentNullException("ambiguousNamespaces");
      
      IsValid = isValid;
      FullTypeName = fullTypeName;
      SuggestedImport = suggestedImport;
      SuggestedImports = suggestedImports;
      IsAmbiguous = isAmbiguous;
      AmbiguousNamespaces = ambiguousNamespaces;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool isValid, [CanBeNull] out string fullTypeName, [CanBeNull] out string suggestedImport, [NotNull] out string[] suggestedImports, out bool isAmbiguous, [NotNull] out string[] ambiguousNamespaces)
    {
      isValid = IsValid;
      fullTypeName = FullTypeName;
      suggestedImport = SuggestedImport;
      suggestedImports = SuggestedImports;
      isAmbiguous = IsAmbiguous;
      ambiguousNamespaces = AmbiguousNamespaces;
    }
    //statics
    
    public static CtxReadDelegate<TypeValidationResponse> Read = (ctx, reader) => 
    {
      var isValid = reader.ReadBool();
      var fullTypeName = ReadStringNullable(ctx, reader);
      var suggestedImport = ReadStringNullable(ctx, reader);
      var suggestedImports = ReadStringArray(ctx, reader);
      var isAmbiguous = reader.ReadBool();
      var ambiguousNamespaces = ReadStringArray(ctx, reader);
      var _result = new TypeValidationResponse(isValid, fullTypeName, suggestedImport, suggestedImports, isAmbiguous, ambiguousNamespaces);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    public static CtxReadDelegate<string[]> ReadStringArray = JetBrains.Rd.Impl.Serializers.ReadString.Array();
    
    public static CtxWriteDelegate<TypeValidationResponse> Write = (ctx, writer, value) => 
    {
      writer.Write(value.IsValid);
      WriteStringNullable(ctx, writer, value.FullTypeName);
      WriteStringNullable(ctx, writer, value.SuggestedImport);
      WriteStringArray(ctx, writer, value.SuggestedImports);
      writer.Write(value.IsAmbiguous);
      WriteStringArray(ctx, writer, value.AmbiguousNamespaces);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    public static  CtxWriteDelegate<string[]> WriteStringArray = JetBrains.Rd.Impl.Serializers.WriteString.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeValidationResponse) obj);
    }
    public bool Equals(TypeValidationResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return IsValid == other.IsValid && Equals(FullTypeName, other.FullTypeName) && Equals(SuggestedImport, other.SuggestedImport) && SuggestedImports.SequenceEqual(other.SuggestedImports) && IsAmbiguous == other.IsAmbiguous && AmbiguousNamespaces.SequenceEqual(other.AmbiguousNamespaces);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + IsValid.GetHashCode();
        hash = hash * 31 + (FullTypeName != null ? FullTypeName.GetHashCode() : 0);
        hash = hash * 31 + (SuggestedImport != null ? SuggestedImport.GetHashCode() : 0);
        hash = hash * 31 + SuggestedImports.ContentHashCode();
        hash = hash * 31 + IsAmbiguous.GetHashCode();
        hash = hash * 31 + AmbiguousNamespaces.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeValidationResponse (");
      using (printer.IndentCookie()) {
        printer.Print("isValid = "); IsValid.PrintEx(printer); printer.Println();
        printer.Print("fullTypeName = "); FullTypeName.PrintEx(printer); printer.Println();
        printer.Print("suggestedImport = "); SuggestedImport.PrintEx(printer); printer.Println();
        printer.Print("suggestedImports = "); SuggestedImports.PrintEx(printer); printer.Println();
        printer.Print("isAmbiguous = "); IsAmbiguous.PrintEx(printer); printer.Println();
        printer.Print("ambiguousNamespaces = "); AmbiguousNamespaces.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
