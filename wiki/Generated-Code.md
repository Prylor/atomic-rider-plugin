# Generated Code Examples

This page shows exactly what C# code is generated from your `.atomic` files.

## Basic Generation

### Input: `Simple.atomic`

```atomic
entityType: Entity
namespace: Game
className: EntityExt

tags:
    Player

values:
    Health: int
```

### Output: `EntityExt.cs`

```csharp
// <auto-generated>
// This code was generated by Atomic Plugin.
// Changes to this file may be lost if the code is regenerated.
// </auto-generated>

using System;
using System.Runtime.CompilerServices;

namespace Game
{
    public static class EntityExt
    {
        // Constants
        private const int PlayerTag = 123456789;
        private const int Health = 987654321;
        
        // Tag: Player
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool HasPlayerTag(this Entity entity)
        {
            return entity.Has(PlayerTag);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddPlayerTag(this Entity entity)
        {
            entity.Add(PlayerTag);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DelPlayerTag(this Entity entity)
        {
            entity.Del(PlayerTag);
        }
        
        // Value: Health
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int GetHealth(this Entity entity)
        {
            return entity.Get<int>(Health);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetHealth(this Entity entity, int value)
        {
            entity.Set(Health, value);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddHealth(this Entity entity)
        {
            entity.Add<int>(Health);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool HasHealth(this Entity entity)
        {
            return entity.Has(Health);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DelHealth(this Entity entity)
        {
            entity.Del(Health);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryGetHealth(this Entity entity, out int value)
        {
            return entity.TryGet(Health, out value);
        }
    }
}
```

## Advanced Generation

### With Aggressive Inlining and Unsafe

```atomic
entityType: Entity
namespace: Game.Components
className: Components
aggressiveInlining: true
unsafe: true

values:
    Position: Vector3
    Health: int
```

### Generated Methods with Unsafe

```csharp
// When unsafe: true, additional ref methods are generated
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static ref Vector3 RefPosition(this Entity entity)
{
    return ref entity.GetRef<Vector3>(Position);
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static ref int RefHealth(this Entity entity)
{
    return ref entity.GetRef<int>(Health);
}
```

## Complex Types

### Input with Complex Types

```atomic
entityType: GameObject
namespace: Game.ECS
className: GameObjectComponents

imports:
    System.Collections.Generic
    UnityEngine

values:
    Inventory: List<Item>
    Attributes: Dictionary<string, float>
    Path: Vector3[]
```

### Generated for Collections

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Runtime.CompilerServices;

namespace Game.ECS
{
    public static class GameObjectComponents
    {
        private const int Inventory = 111111111;
        private const int Attributes = 222222222;
        private const int Path = 333333333;
        
        // List<Item> methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static List<Item> GetInventory(this GameObject entity)
        {
            return entity.Get<List<Item>>(Inventory);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetInventory(this GameObject entity, List<Item> value)
        {
            entity.Set(Inventory, value);
        }
        
        // Dictionary<string, float> methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Dictionary<string, float> GetAttributes(this GameObject entity)
        {
            return entity.Get<Dictionary<string, float>>(Attributes);
        }
        
        // Vector3[] methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector3[] GetPath(this GameObject entity)
        {
            return entity.Get<Vector3[]>(Path);
        }
        
        // ... other standard methods (Has, Add, Del, TryGet)
    }
}
```

## Multiple Files Organization

### Physics.atomic

```atomic
entityType: Entity
namespace: Game.Physics
className: PhysicsComponents

values:
    Velocity: Vector3
    Mass: float
    Drag: float
```

### Combat.atomic

```atomic
entityType: Entity
namespace: Game.Combat
className: CombatComponents

values:
    Health: int
    Damage: int
    Armor: float
```

### Usage in Code

```csharp
using Game.Physics;
using Game.Combat;

public class GameLogic
{
    public void UpdateEntity(Entity entity)
    {
        // From PhysicsComponents
        if (entity.HasVelocity())
        {
            var velocity = entity.GetVelocity();
            var mass = entity.GetMass();
        }
        
        // From CombatComponents
        if (entity.HasHealth())
        {
            var health = entity.GetHealth();
            entity.SetHealth(health - 10);
        }
    }
}
```

## Custom Header

### With Custom Header

```atomic
header: |
    // ================================
    // Generated by Atomic Plugin v0.1.0
    // Author: Your Name
    // Do not modify manually!
    // ================================

entityType: Entity
namespace: Game
className: Components

values:
    Score: int
```

### Generated with Header

```csharp
// ================================
// Generated by Atomic Plugin v0.1.0
// Author: Your Name
// Do not modify manually!
// ================================

using System;
using System.Runtime.CompilerServices;

namespace Game
{
    public static class Components
    {
        // ... rest of generated code
    }
}
```

## Hash Generation

The plugin generates unique hash codes for each tag and value:

```csharp
// Hashes are deterministic based on the name
private const int PlayerTag = 1234567890;  // Hash("Player")
private const int HealthValue = 987654321; // Hash("Health")
```

## Method Patterns

### Standard Pattern

All generated methods follow consistent patterns:

| Method | Pattern | Purpose |
|--------|---------|---------|
| Get | `Get{Name}()` | Retrieve value |
| Set | `Set{Name}(T value)` | Update value |
| Add | `Add{Name}()` | Add component |
| Has | `Has{Name}()` | Check existence |
| Del | `Del{Name}()` | Remove component |
| TryGet | `TryGet{Name}(out T value)` | Safe retrieval |
| Ref | `Ref{Name}()` | Get reference (unsafe only) |

### Tag Pattern

Tags have a simpler pattern:

| Method | Pattern | Purpose |
|--------|---------|---------|
| Has | `Has{Name}Tag()` | Check if tagged |
| Add | `Add{Name}Tag()` | Apply tag |
| Del | `Del{Name}Tag()` | Remove tag |

## Performance Optimizations

### With Aggressive Inlining

When `aggressiveInlining: true`:

```csharp
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static int GetHealth(this Entity entity)
{
    // Method body is inlined at call site
    return entity.Get<int>(Health);
}
```

### Without Aggressive Inlining

When `aggressiveInlining: false` or not specified:

```csharp
public static int GetHealth(this Entity entity)
{
    // Normal method call
    return entity.Get<int>(Health);
}
```

## Unity-Specific Generation

For Unity projects, the generated file location considers:
- Assets folder structure
- Assembly definition files (.asmdef)
- Project-relative paths

## Regeneration Behavior

### What Triggers Regeneration

1. Manual trigger (Ctrl+Shift+G)
2. File save (if auto-generation enabled)
3. Changes to these fields:
   - `entityType`
   - `namespace`
   - `aggressiveInlining`
   - `unsafe`
   - Any imports
   - Any tags
   - Any values

### What Doesn't Trigger Regeneration

Changes to these fields only update the file, not regenerate:
- `header`
- `className` (renames file)
- `directory` (moves file)
- Comments

## Error Handling

If generation fails, the plugin:
1. Shows error notification
2. Preserves existing generated file
3. Logs detailed error information
4. Provides quick fixes when possible